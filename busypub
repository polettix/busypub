#!/usr/bin/env perl
use 5.024;
use Moo;
use warnings;
use experimental qw< postderef signatures >;
no warnings qw< experimental::postderef experimental::signatures >;

use Git::Wrapper;
use Try::Catch;
use POSIX 'strftime';
use Path::Tiny 'path';
use Log::Log4perl::Tiny qw< :easy >;
use MIME::Base64 'decode_base64';

has dir        => (is => 'ro', default => 'myblog');
has git        => (is => 'lazy');
has private    => (is => 'ro', required => 1);
has public     => (is => 'ro', required => 1);
has sleep_time => (is => 'ro', default => 10 * 60);    # 10 minutes
has ssh_config => (is => 'ro', default => undef);
has ssh_key    => (is => 'ro', init_arg => 'key');

exit(
   sub (@args) {
      my %config = (dir => 'tmp');
      for my $key (qw< DIR PRIVATE PUBLIC KEY SSH_CONFIG SLEEP_TIME >) {
         $config{lc $key} = $ENV{$key} if defined $ENV{$key};
      }
      __PACKAGE__->new(\%config)->run;
   }
     ->(@ARGV)
) unless caller;

sub run ($self) {
   try {
      $self->ensure_ssh_setup if $self->ssh_key;
      $self->ensure_local_master();
   }
   catch {
      FATAL $_;
      exit 1;
   };

   while ('necessary') {
      try {
         my $today = strftime '%Y-%m-%d', localtime;
         INFO "attempting update for <$today>";

         # wipe out whatever we have cached and re-read from remotes
         $self->delete_tag($today);
         $self->refresh_local_copy;

         if ($self->has_tag($today)) {
            $self->advance_to_tag($today);
            $self->update_public;
            INFO 'update done';
         }
         else {
            ERROR "no tag for <$today>";
         }
      } ## end try
      catch {
         ERROR $_;
      };
      sleep $self->sleep_time;
   } ## end while ('necessary')
} ## end sub run ($self)

sub _build_git ($self) { return Git::Wrapper->new($self->dir) }

sub ensure_ssh_setup ($self) {
   my $ssh_dir = path("$ENV{HOME}/.ssh");
   $ssh_dir->mkpath;
   $ssh_dir->chmod(0700);

   my $ssh_key = $ssh_dir->child('id_rsa-busypub');
   $ssh_key->spew_utf8(decode_base64($self->ssh_key));
   $ssh_key->chmod(0600);

   my $ssh_config = $ssh_dir->child('config');
   my $ssh_config_content =
       defined($self->ssh_config) ? decode_base64($self->ssh_config)
     : $ssh_config->exists        ? undef
     : <<'END'
Host *
   StrictHostKeyChecking no
   UserKnownHostsFile /dev/null
   IdentityFile ~/.ssh/id_rsa-busypub
END
     ;
   if (defined $ssh_config_content) {
      $ssh_config->spew_utf8($ssh_config_content);
      $ssh_config->chmod(0600);
   }

   return;
} ## end sub ensure_ssh_setup ($self)

sub ensure_local_master ($self) {
   try {
      $self->git->checkout('master');
   }
   catch {
      $self->reset_local_copy;
      $self->git->checkout(qw< -b master public/master >);
   };
} ## end sub ensure_local_master ($self)

sub reset_local_copy ($self) {
   my $dir = $self->dir;
   my $git = $self->git;
   path($dir)->remove_tree({safe => 0});
   INFO "cloning private repo into $dir";
   $git->clone(qw< -o private >, $self->private, $dir);
   INFO 'fetching public repo';
   $git->remote(add => public => $self->public);
   $git->fetch('public');
   return;
} ## end sub reset_local_copy ($self)

sub refresh_local_copy ($self) {
   my $git = $self->git;
   INFO 'fetching public repo';
   $git->fetch(qw< public        >);
   INFO 'fetching private repo';
   $git->fetch(qw< private --tag >);
} ## end sub refresh_local_copy ($self)

sub has_tag ($s, $t) {
   scalar grep { $t eq $_ } $s->git->tag;
}

sub delete_tag ($self, $tag) {
   return unless $self->has_tag($tag);
   $self->git->tag(-d => $tag);
}

sub advance_to_tag ($s, $t) { $s->git->merge('--ff-only' => $t) }

sub update_public ($s) { $s->git->push(public => 'master') }
